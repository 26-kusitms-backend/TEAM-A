# 스프링 프레임워크 특징

## DI

의존 관계 주입은 어떤 객체가 사용하는 의존 객체를 직접 만들어 사용하는 게 아니라, 외부에서 생성된 객체를 주입 받아 사용하는 방법이다. 

DI를 통해

1) 객체간 결합도가 낮아져 단위 테스트가 쉬워진다.

2) 코드 재사용과 코드의 유연성이 높아진다.

-> DI를 통해 미리 정의된 코드가 호출되는 것이 아니기에 유연하다는 표현을 사용한다.

3) 코드의 주옵ㄱ을 막을 수 있고, 가독성이 좋아진다.

이 3가지의 장점을 얻을 수 있다.

DI를 하는 방법은 생성자 주입, 필드 주입, 세터 주입이 있다. 

필자는 주로 생성자 주입이나 `@RequiredArgsConstructor` 어노테이션을 사용하는 편이다.

## IoC

Inversion of Control의 약자이다.

제어의 역전이 무엇인지 이해하기에 앞서 의존성이 무엇인지 이해하고 넘어가자.

Controller에서 Service에 있는 비즈니스 로직을 호출한다. 이 상황에서는 Controller가 Service를 의존하고 있음을 알 수 있다. 

명확히 얘기하면, 의존하다는 의미는 Controller가 Service를 멤버 변수나 로컬 변수로 가지고 있거나 혹은 파라미터로 전달되거나 Service의 메소드를 호출하는 것을 의미한다.

만약 Service가 변경되면 Controller는 Service를 강하게 의존하고 있으므로 컴파일 오류 혹은 그 밖에 오류가 발생할 수 있다. 또한, 이러한 강한 의존성은 Controller를 재사용하기 어렵게 만든다.

그래서 스프링에서는 스프링 컨테이너가 빈 객체를 통해 객체의 생명 주기를 관리한다. 

## 스프링 컨테이너

스프링 컨테이너는 객체의 생명 주기를 관리하며 생성된 인스턴스들에게 다양한 긴으을 제공해준다. 스프링 컨테이너는 자바 객체를 담고 있으며, 컨테이너 안에 필요한 객체를 가져와 사용할 수 있다. 

스프링 컨테이너는 2종류이다. 

### 1. 빈 팩토리

표현 그대로 빈 객체의 공장이다. 이곳에서 빈을 등록하고, 생성하고, 조회하고 호출하는 기능을 담당한다.

빈 팩토리는 RUN을 시키면 빈의 코드 상의 정의된 내용을 즉시 로딩해오지만, 실제로 로직에서 사용되기 전까지는 인스턴스화하지 않는다.

getBean() 를 통해 호출되면 팩토리는 의존성 주입을 통해 빈을 인스턴스화하고 빈의 특성을 설정한다. 이때부터 빈의 생명주기가 시작된다.

스프링 컨테이너에 빈을 등록하는 방법으로는 어노테이션을 사용하거나 Bean Configuration File에 직접 등록하는 방법이 있다.

### 2. 어플리케이션 컨텍스트

ApplicationContext는 빈 팩토리를 상속하여 확장한 컨테이너라고 보면 된다.

기본적인 기능은 빈 팩토리와 동일하나 스프링이 제공하는 각종 부가 기능을 추가로 제공한다. 여기에는 트랜잭션 관리, AOP 등이 있다.

어플리케이션 컨텍스트는 컨텍스트 초기화 시점에 미리 빈을 생성해두고 실제로 빈이 필요할 때 즉시 사용할 수 있도록 해준다.

### 3. 둘의 차이점

가장 큰 차이는 **미리 만들어두는 것인가 아니면 호출된 시점에 만들어지는 가**이다.

빈 팩토리의 경우에는 처음으로 getBean()이 호출된 시점에 해당 빈을 생성한다. -> lazy 로딩

어플리케이션 컨텍스트는 컨테이너가 구동되는 시점에 미리 빈을 로드하고 생성하여 pre-loading한 후 필요할 때 즉시 사용할 수 있도록 한다.

https://terianp.tistory.com/50
https://develogs.tistory.com/19

## 이벤트

스프링은 내부에 이벤트라는 메커니즘을 갖고 있다. 이는 스프링의 빈과 빈 사이의 데이터를 전달하는 방법 중 하나이다. 

일반적으로 데이터를 전달하는 방법은 DI를 통해서 이루어진다. 이벤트는 이와는 다른 방법이다.

빈에서 이벤트를 어플리케이션 컨텍스트로 넘겨주고 이를 리스너에서 받아 처리한다.

스프링 내에 정의되어 있는 이벤트는 아래와 같다.

- ContextRefreshedEvent

어플리케이션 컨텍스트를 초기화하거나 refresh할 때 발생

- ContextStartedEvent

어플리케이션 컨텍스트를 start하여 빈의 생명주기가 시작하는 신호를 받는 시점에 발생

- ContextStoppedEvent

어플리케이션 컨텍스트를 stop하여 빈이 정지 신호를 받은 시점에 빌생

- ContextClosedEvent

어플리케이션 컨텍스트를 close하여 싱글톤 빈이 소멸되는 시점에 발생

- RequestHandleredEvent

HTTP 요청을 처리했을 때 발생

스프링의 이벤트 처리는 단일 스레드에서 처리되므로 이벤트가 게시되면 모든 리스너가 받을 때까지 프로세스가 차단되고 흐름이 계속되지 않는다. ( 서버가 중단이 된다. )

### Context Event 수신

컨텍스트 이벤트를 수신하려면 빈은 onApplicationEveent() 를 갖는 리스너 인터페이스를 구현해야 한다. 

https://atoz-develop.tistory.com/entry/Spring-ApplicationEventPublisher%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D

위의 링크를 통해 테스트 코드를 볼 수 있다.

### 언제 왜 사용할까?

1. Warm up 코드 작성 시

Application Ready Event 발생 시, 서비스 관련된 부분의 상태를 확인한다. 예를 들면, DB, Cache, Elastic Search, Message Queue 등이 있다.

등록된 서비스를 테스트하고 L4 ( 전송 계층 )에서 확인하는 Health Check를 활성화시켜준다.

2. 서비스 중지 이벤트 처리

서비스를 중지 시키면 ConextClosedEvent가 발생한다. 이때 필요한 코드를 추가할 수 있다.


https://reflectoring.io/spring-boot-application-events-explained/

https://blog.naver.com/PostView.nhn?blogId=gngh0101&logNo=222363176425&parentCategoryNo=&categoryNo=20&viewDate=&isShowPopularPosts=true&from=search

https://eblo.tistory.com/165

## 데이터 바인딩

어떤 프로퍼티의 값을 target 객체에 설정하는 것을 의미한다. 예를 들면, 클라이언트로부터 넘어온 값을 도메인 객체에 동적으로 할당하는 기능이다.

DTO를 명세해서 프론트와 백이 주고 받는 데이터 형식이 다름에도 불구하고 DTO 클래스의 멤버 변수에 정의된 타입으로 사용 가능한 이유가 바로 이것이다. 스프링부트에서는 이를 자동으로 지원해주고 있다.

https://hongchan.tistory.com/9

## AOP

OOP를 보완하는 수단으로, 흩어진 Aspect를 모듈화할 수 있는 프로그래밍 기법이다. 즉, 여러 곳에서 쓰이는 공통 기능을 모듈화하고 필요한 곳에 연결하여 사용함으로써 유지 보수와 재사용에 용이하도록 프로그래밍하는 것이다.

### 구성 요소

- Aspect : 여러 곳에서 쓰이는 코드를 모듈화한 것
- Target : Aspect가 적용되는 곳
- Advice : Aspect에서 실질적인 기능에 대한 구현체
- Joint Point : Advice가 Target에 적용되는 시점으로 주로 메소드를 진입할 때, 생성자를 호출할 때, 필드에서 값을 꺼낼 때 등이 있다.
- Point cut : Joint point의 상세 스펙을 정의한 것

## 모의 객체

Mock은 가짜 객체를 의미한다. 

그루터기 프로젝트에서 RestDocs를 위한 테스트 코드 작성을 떠올려보자. 하나의 API 기능을 테스트하기 위해 View를 그리고 axios 통신을 하는 등의 번거로움이 있다. 스프링에서는 이를 테스트 코드를 통해 API 기능 검증을 할 수 있도록 도와준다.

Mockito는 단위 테스트를 하기 위한 Mock을 만들어주는 Java Mocking Framework이다.

Mockito를 사용하기 위해서는 관련된 dependency르 추가해야 하고, 코드 상에서 Mock 객체를 생성해주어야 한다. 이를 위해서 어노테이션을 사용해도 되고, 메소드를 통해서 생성해도 된다.

## TestContext Framework

테스트에 사용되는 어플리케이션 컨텍스트를 생성하고 관리하여 테스트에 적용해주는 테스트 프레임워크이다. 실제 서버와 거의 동일한 구성으로 동작하는 어플리케이션 컨텍스트를 손쉽게 만들 수 있도록 해준다. 

JUnit은 테스트 메소드를 실행할 때마다 매번 새로운 객체의 테스트 클래스를 만든다. 그래서 모든 테스트가 서로 영향을 주지 않으며 독립적으로 실행되는 것이 보장된다. 

그런데, 테스트가 독립적이어서 매번 별개의 어플리케이션 컨텍스트를 만들어야 한다. JPA와 같은 ORM에서 처리하는 초기화 작업이나 캐시 사용을 위한 시간 소모가 된다.

그래서 스프링은 테스트가 사용하는 컨텍스트를 캐시애서 여러 테스트가 1개의 컨텍스트를 공유하는 방법을 제공한다. 이는 메소드 단위가 아닌 클래스 단위에서도 가능하다. 

https://mangkyu.tistory.com/202

## 트랜잭션

트랜잭션은 여러 작업을 진행하다가 문제가 생겼을 경우, 이전 상태로 롤백하기 위해 사용되는 것이다. 트랜잭션은 더 이상 쪼갤 수 없는 최소 작업 단위를 의미한다.

스프링에서 제공하는 트랜잭션 기술은 '트랜잭션 동기화', '트랜잭션 추상화', 'AOP를 이용한 트랜잭션 분리'가 있다.

### 1. 트랜잭션 동기화

JDBC를 이용한 개발자가 직접 여러 개의 작업을 하나의 트랜잭션으로 관리하려면 Connection 개체를 공유하는 등의 상당히 불필요한 작업들이 많이 생긴다. 그래서 스프링에서는 트랜잭션 동기화 기술을 제공한다.

트랜잭션 동기화는 트랜잭션을 시작하기 위한 Connection 객체를 특별한 저장소에 보관해두고 필요할 때 꺼내 쓸 수 있도록 하는 기술이다. 이 저장소는 Worker Thread 마다 Connection 객체를 독립적으로 관리하기 때문에, 멀티 스레드 환겨여에서도 Thread-safe하다.

하지만 개발자가 JDBC가 아닌 Hbiernate와 같은 기술을 쓴다면 위의 JDBC 종속적인 트랜잭션 동기화 코드들은 에러를 뱉는다. 대표적인 에러가 Hibernate에서는 Connection이 아닌 Session이라는 객체를 사용한다는 점이다. 그래서 스프링은 이러한 기술 종속적 문제를 해결하기 위해 트랜잭션 추상화 기술을 제공한다.

### 2. 트랜잭션 추상화

트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술은 JDBC, JPA, Hibernate 등 종속적인 코드를 이용하지 않고도 일관되게 트랜잭션을 처리할 수 있도록 해준다. 

### 3. AOP를 이용한 트랜잭션 분리

트랜잭션 코드와 비즈니스 로직 코드가 복잡하게 얽혀있다면, 이 코드는 여러 책임을 가지게 된다. 그래서 분리하는 것이 적합하다.

스프링에서는 트랜잭션 코드를 클래스 밖으로 빼내서 별도의 모듈로 만드는 AOP 방식을 만들었고, 이로 인해 등장한 것이 @Transactional 어노테이션이다.

https://mangkyu.tistory.com/154