# 트랜잭션

## Transactional

스프링 컨테이너는 같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다.

@Transactional 어노테이션을 쓰면 메소드 호출 전에 스프링 트랜잭션 AOP가 동작한다. AOP가 트랜잭션 COMMIT과 Rollback을 해준다.

스프링은 이 어노테이션을 갖는 애를 포인트 컷의 대상으로 자동 등록하며 트랜잭션의 관리 대상으로 여긴다. ( 트랜잭션의 속성을 부여한다. ) 이렇게 어노테이션을 이용한 것을 선언적 트랜잭션이라 한다. 어노테이션을 통해 메소드 단위로 트랜잭션 속성을 다르게 지정할 수 있어 세밀한 작업이 가능하다.

## 롤백 처리

자바에는 checked exception 과 unchecked exception이 있다. 둘을 구분하는 것은 중요하다. 트랜잭션의 롤백 범위가 다르기 때문이다. checked exception이란 exception 클래스의 하위 클래스이며, unchecked exception은 runtime exception 클래스의 하위 클래스이다. 

만약 예외가 발생했는데, 이게 unchecked라면 런타임에서 발생한 오류이기에 자동 롤백이 된다. 하지만 checked이면 롤백이 되지 않는다. checked를 롤백하기 위해서는 어노테이션에 rollbackFor 속성으로 예외를 명시해야 한다.

스프링에서 unchecked를 롤백의 대상으로 보는 이유는 해당 예외들이 복구 가능성이 없는 예외들이므로 별도의 try-catch나 throw를 통해 처리를 강제하지 않기 때문이다.

# 트랜잭션

데이터베이스에 있는 데이터를 수정 혹은 삭제하는 도중 예기치 못한 오류가 발생한다면 어떻게 해야 할까? 데이터베이스에 있는 데이터들은 수정이 되기 전의 상태로 되돌아가져야 하고 실행했던 작업이 재진행되어야 할 것이다.

여러 작업을 진행하다가 문제가 생겼을 경우, 이전 상태로 롤백하기 위해 사용되는 것이 트랜잭션이다.

트랜잭션은 더 이상 쪼갤 수 없는 최소 작업 단위를 뜻한다. 그렇기에 트랜잭션은 성공과 실패만이 존재한다. 성공한 경우 커밋, 실패한 경우에는 롤백으로 그 이전 상태로 되돌아가야 한다. 모든 트랜잭션이 동일한 것은 아니고, 속성에 따라 동작 방식을 다르게 해줄 수 있다. 예를 들어 1개의 새로운 데이터를 추가하는 도중에 오류가 발생하면 해당 추가 작업은 없었던 것처럼 되돌려진다. 하지만 여러 개의 작업에 대해 오류로 인한 롤백을 해야 한다면 어떻게 해야 할까? 여러 개의 작업을 1개의 트랜잭션으로 관리해야 한다.

트랜잭션은 앞서 설명한 것처럼 성공과 실패로 인한 이전의 상태로 되돌아가는 2가지의 케이스가 있다. 만약 여러 작업이 모두 성공했다면 트랜잭션 커밋을 통해 작업이 마무리되었음을 알려주어 데이터베이스에 반영해야 하며, 실패했다면 작업 취소를 위해 트랜잭션 롤백 처리를 해야 한다.

## 스프링에서 트랜잭션

스프링에서 트랜잭션과 관련한 기술은 크게 3가지이다.

1. 트랜잭션 동기화
2. 트랜잭션 추상화
3. AOP를 이용한 트랜잭션 분리

### 1. 트랜잭션 동기화

JDBC를 이용하는 프로젝트에서 개발자가 직접 여러 개의 작업을 하나의 트랜잭션으로 관리하려면 Connection 객체를 공유하는 등 번거로운 작업들이 많이 생길 것이다.

스프링은 이러한 문제를 해결하고자 트랜잭션 동기화 기술을 제공하고 있다. 트랜잭션 동기화는 트랜잭션을 시작하기 위한 connection 객체를 특별한 저장소에 보관해두고 필요할 때 꺼내쓸 수 있도록 하는 기술이다. 

트랜잭션 동기화는 작업 스레드마다 connection 객체를 독립적으로 관리하기 때문에, 멀티스레드 환경에서도 충돌이 발생할 여지가 없다. 

스프링 프로젝트를 할 때 가장 많이 접하는 hibernate를 사용할 경우, connection이 아닌 session이라는 객체를 사용하기 때문에 이슈가 발생한다. 이러한 기술 종속적 이슈를 해결하기 위해 스프링은 트랜잭션 관리 부분을 추상화한 기술을 제공한다.

### 2. 트랜잭션 추상화

스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공하고 있다. 이를 이용함으로써 어플리케이션에 각 기술마다 종속적인 코드를 이용하지 않고도 일관되게 트랜잭션을 처리할 수 있도록 해주고 있다. 

스프링이 제공하는 트랜잭션 경계 설정을 위한 추상 인터페이스는 PlatformTransactionManager이다. 

### 3. 트랜잭션 AOP

트랜잭션 코드와 비즈니스 로직 코드가 복잡하게 얽혀 있다면 어떻게 해야 할까? 이럴 경우, 하나의 로직에서 여러 책임을 지게 된다. 어떤 책임? 비즈니스 로직과 트랜잭션에 대한 책임. 그럼 분리시켜보자! 어떻게? 스프링에서는 트랜잭션 코드가 마치 존재하지 않는 것처럼 보이게 하는 AOP 프로그래밍을 지원한다. 이게 바로 `@Transactionl`이다.

## 트랜잭션의 세부 설정

스프링의 DefaultTransactionDefinition이 구현하고 있는 TransactionDefinition 인터페이스는 트랜잭션의 동작 방식에 영향을 줄 수 있는 4가지 속성을 정의하고 있다.

### 1. 트랜잭션 전파
트랜잭션의 경계에서 이미 진행중인 트랜잭션이 있거나 없을 때, 어떻게 동작할 것인가를 결정하는 방식을 의미한다. 예를 들어 어떤 작업 A에 대한 트랜잭션이 진행중이고 B작업이 시작될 때, B작업에 대한 트랜잭션을 어떻게 처리할까에 대한 부분이다.

1. A의 트랜잭션에 참여시킨다.

B의 코드는 새로운 트랜잭션을 만들지 않고 A에서 진행중인 트랜잭션에 참여할 수 있다. 이 경우, A에서 에러 나면 B도 커밋되지 않는다. 

1. 독립적인 트랜잭션 생성한다.

B의 독립적인 트랜잭션을 생성할 수 있다. 이 경우, A와 B는 서로의 작업에 영향을 주지 않는다.

1. 트랜잭션 없이 동작한다.

B의 작업에 대해 트랜잭션을 걸지 않을 수 있다. 단순 데이터 조회의 경우, 굳이 트랜잭션을 걸 필요가 없다.

> 조회가 아닌 경우에는 트랜잭션을 걸어야 하는가?

전파 속성에는 7가지 속성이 있다.

- Required

기본 속성으로 모든 트랜잭션을 매니저가 지원한다. 대부분의 경우 이 속성이면 충분하다. 미리 시작된 트랜잭션이 있으면 참여하고 없으면 새로 시작한다. 하나의 트랜잭션이 시작된 후 다른 트랜잭션 경계가 설정된 메소드를 호출하면 자연스럽게 같은 트랜잭션으로 묶인다.

- Supports

이미 시작된 트랜잭션이 있으면 참여하고 없으면 트랜잭션 없이 진행한다. 트랜잭션이 없어도 해당 경계 안에서 connection 객체나 session 을 공유할 수는 있다.

- Mandatory

이미 시작된 트랜잭션이 있으면 참여한다. 하지만 이미 시작된 트랜잭션이 없다면 예외를 던진다. 그렇기에 혼자서 독립적으로 트랜잭션을 진행하면 안되는 경우에 사용할 수 있다.

- requires_new

항상 새로운 트랜잭션을 시작해야 하는 경우에 사용한다. 만약 이미 시작된 트랜잭션이 있다면 그걸 잠시 보류시키고 새로운 트랜잭션을 만든다.

- not_supported

이미 진행중인 트랜잭션이 있으면 이를 보류시키고 트랜잭션을 사용하지 않도록 한다.

- never

이미 진행중인 트랜잭션이 있음녀 예외를 던진다. 트랜잭션을 사용하지 않도록 강제할 때 사용한다.

- nested

이미 진행중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다. 중첩 트랜잭션은 트랜잭션 안에 다시 트랜잭션을 만드는 것으로 requires_new와는 다르다. 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만, 자식의 트랜잭션은 부모에게 영향을 주지 않는다.

비즈니스 로직과 로깅을 남기는 트랜잭션이 있다고 하자. 로깅이 실패했다고 비즈니스 로직 트랜잭션까지 죽어야 할까?

### 2. 격리 수준

모든 데이터베이스 트랜잭션은 격리 수준을 가지고 있어야 한다. 서버에서는 여러 개의 트랜잭션이 동시에 진행될 수 있는데, 모든 트랜잭션을 독립적으로 만들고 순차 진행 한다면 안전하겠지만 성능이 크게 떨어질 수 밖에 없다. 따라서 적절하게 격리 수준을 조정해서 가능한 많은 트랜잭션을 동시에 진행시키면서 문제가 발생하지 않도록 제어해야 한다.

### 3. 제한 시간

트랜잭션을 수행하는 제한 시간을 설정할 수 있다. 이는 트랜잭션을 직접 시작하는 PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW의 경우에 유의미하다.

### 4. 읽기 전용

읽기 전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있을 뿐만 아니라 데이터 접근 기술에 따라 성능이 향상될 수 있다.

[[Spring] Spring에서 트랜잭션의 사용법 - (3/3)](https://mangkyu.tistory.com/170)