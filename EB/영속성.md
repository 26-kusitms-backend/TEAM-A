# 영속성

영속성은 데이터를 생성한 프로그램이 종료되더라도 사라지지 않는 데이터의 특성이다. 영속성이 없는 데이터는 단지 메모리에서만 존재하므로 프로그램이 종료되면 모두 사라진다.

프로그램은 메모리에 올라와야 실행 가능한 상태가 되고, 실행 중에 쌓이는 데이터들을 영구적으로 저장하고 싶다면 영속 상태로 만들어야 한다. 

자바에서 데이터를 저장하는 방식은 크게 JDBC, Persistence Framework를 이용하는 것이 있다.

## 영속성 상태 분류

1. 비영속

`new` 혹은 `transient` 상태를 비영속 상태라 한다. 이 상태는 영속성 컨텍스트와 전혀 관계가 없는 상태이다. 엔티티 객체를 생성하였지만, 아직 영속성 컨택스트에 저장하지 않는 상태이다. 

2. 영속

`managed` 상태를 영속 상태라 한다. 영속성 컨텍스트에 저장된 상태이다. 영속 상태여도 바로 DB에 저장되지 않고 트랜잭션의 commit 시점에 영속성 컨텍스트에 있는 정보들을 DB에 쿼리로 날린다.

3. 준영속

`detached` 상태를 준영속 상태라 한다. 영속성 컨텍스트에 저장되었다가 분리된 상태이다. 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않는다. 

4. 삭제

`removed` 상태를 삭제 상태라 한다.  영속성 컨텍스트와 DB에서 해당 엔티티를 삭제한 상태이다. 

## 영속성 컨텍스트
영속성 컨텍스트는 엔티티를 영구 저장하는 환경이다. 어플리케이션과 DB 사이에서 객체를 보관하는 가상의 DB 같은 역할이다. 서비스별로 하나의 entityManager factory가 존재하며, DB에 접근하는 트랜잭션이 생길 때마다 스레드 별로 entityManager를 생서하여 영속성 컨텍스트에 접근한다.

entityManager에 엔티티를 저장하거나 조회하면, entityManager는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.

### EntityManager

영속성 컨텍스트 내에서 엔티티를 관리한다. JPA에서 제공하는 인터페이스로 스프링 빈으로 등록되어 있어 Autowired 어노테이션을 이용해 사용할 수 있다. 쿼리 함수와 Repository 인터페이스는 직접적으로 EntityManager를 사용하지 않도록 한 번 더 감싼 형태이다.

## 영속성 컨텍스트 특징

1. 1차 캐시

`save()`와 같이 DB에 변경을 가하는 메소드를 실행했을 때, 바로 DB가 업데이트 되지 않고 영속성 컨텍스트 내부에 있는 캐시를 거쳐서 DB가 업데이트 된다. 이를 1차 캐시라 한다.

하나의 트랜잭션에서 id 값으로 조회하는 entity들은 1차 캐시에 저장하여 관리함으로써 JPA 조회 성능이 올라간다.
단, 1차 캐시는 스레드 간에 공유하지 않고 하나의 스레드가 시작할 때부터 끝날 때까지 잠깐 사용한다. ( 왜? entityManager가 서비스별로 생성되고, 서비스는 하나의 request 별로 쓰이고, 이들은 모두 하나의 스레드에서 동작하기 때문이다. )

2. 쓰기 지연

entity 값을 변경하면 DB에 바로 업데이트 하지 않는다. 트랜잭션 내부에서 영속 상태의 entity 값을 변경하면 insert 쿼리들은 DB에 바로 적용되지 않고 쿼리 저장소에 쿼리문을 쌓아둔다.

쿼리 저장소에 쌓인 쿼리들은 entityManager의 `flush`나 트랜잭션의 commit을 통해 보내진다.

3. 변경 감지

트랜잭션을 commit 하면 entityManager의 내부에서 먼저 `flush`가 호출된다.

entity와 스냅샷을 비교하여 변경된 entity를 찾는다.

변경된 entity가 있으면 update 쿼리를 생성해서 쓰기 지연 쿼리 저장소에 저장한다.

쓰기 지연 쿼리 저장소에 쌓인 쿼리들을 `entityManager.flush`한다.

DB에 트랜잭션을 commit 한다.

